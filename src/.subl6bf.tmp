  ; HonkeyPong main program bank, 16KB

  ; A bit about segmentation before we start:
  ; We use two segments here, .data and .text
  ; Each segment contains its own Program Counter 
  ; to keep track of where we are in the data.
  ; This means we can build up the data segment
  ; in one location, and build the text segment
  ; in another without worrying about overwriting
  ; data due to conflicting program counters.

  .data

  ; .org is simply a directive telling the assembler
  ; where in memory a particular block should be 
  ; assumed to be placed. In this particular case,
  ; we are placing variables at the start of RAM.

  .org $0000

  ; Game variables, stored on Zero Page
  .space  ScoreP1         1
  .space  ScoreP2         1
  .space  ButtonsP1       1
  .space  ButtonsP2       1
  .space  BallX           1
  .space  BallY           1
  .space  BallBottom      1
  .space  BallUp          1
  .space  BallDown        1
  .space  BallLeft        1
  .space  BallRight       1
  .space  BallSpeedX      1
  .space  BallSpeedY      1
  .space  BallFrame       1
  .space  Paddle1YTop     1
  .space  Paddle1YBot     1
  .space  Paddle2YTop     1
  .space  Paddle2YBot     1
  .space  GameState       1
  .space  MapAddr         2
  .space  TempY           1
  .space  TempX           1
  .space  TempCounter     1
  .space  TitleShowing    1
  .space  FieldRendered   1
  .space  ScoreP1Updated  1
  .space  ScoreP2Updated  1
  .space  GameOverShowing 1

  ; 3-byte scratchpad for Famitone,
  ; stored at end of zero page.
  .org $00F0
  .space  FT_TEMP         3

  .org $0200
  ; The ball sprite is split into 3 variables so
  ; we can alter things like palette and rotation.
  .space  Ball              2
  .space  BallAttr          1
  .space  BallXPos          1

  ; Game Sprites, 4 bytes per sprite.
  ; Paddle Tile Index, Rotation, Palette and
  ; X Position are fixed, so 1 var each is OK.
  .space  PaddleP1Top       4
  .space  PaddleP1Mid       4
  .space  PaddleP1Bot       4
  .space  PaddleP2Top       4
  .space  PaddleP2Mid       4
  .space  PaddleP2Bot       4

  ; One page of RAM reserved for Famitone sound library.
  .org $0300
  .space  FT_BASE_ADR       256

  ; Start of the text segment, this is our program code.
  .text

  ; Note that .org (origin) is set to $C000. This doesn't
  ; mean that the binary file starts at 0xC000, only that
  ; all assembled code should be assumed to start here,
  ; and the program counter should be assumed at the 
  ; current program offset + 0xC000. The reason we do this
  ; is so that when the program is loaded in the NES, the
  ; addressing is in the right place. PRG-ROM is located
  ; at $8000-$FFFF in the NES memory map. Since this is a
  ; 16KB program, we place it in the upper 16KB ROM space
  ; of the NES 32KB PRG-ROM range ($C000). For a larger
  ; 32KB program, the initial code segment would have an
  ; origin of $8000 instead.
  .org $C000

  ; Just like headers in C and C++, assembly files that are
  ; included in your program are appended to the location 
  ; where the include directive is placed. Generally, it's
  ; a good idea to include headers containing declarations
  ; in sequence before they're used or called, though it
  ; isn't mandatory. It just helps keep everything clean.

  .include "ppu.oph"              ; PPU routines
  .include "setup.oph"            ; NES setup routines
  .include "render.oph"           ; Rendering routines
  .include "sprites.oph"          ; Sprite tables
  .include "input.oph"            ; Controller handler
  .include "engine.oph"           ; Main gameplay stuff
  .include "famitone2.oph"        ; Audio library

RESET:
  ; Make sure everything gets set up properly.
  JSR ResetNES    ; Basic boilerplate NES setup code
  JSR WaitVBlank  ; VBlank #1
  JSR ClearRAM    ; Clear out RAM
  JSR WaitVBlank  ; VBlank #2
  JSR DisableGFX  ; Disable graphics

  ; PPU should be warmed up now (After 2 VBlanks), set up the game.

  ; STATETITLECARD isn't accounted for in the state machine,
  ; but it doesn't matter, since it's only set at power-on
  ; and reset, and at that point NMI is turned off.
  LDA #STATETITLECARD
  STA GameState
  LDA #$00
  STA TitleShowing
  STA ScoreP1Updated
  STA ScoreP2Updated

  ; Load the title card palette.
  `LoadPalette honkeyPal

  ; OR some bitmasks together to set the PPU how we want it.
  ; (Note that NMI and rendering are disabled here, so we don't
  ; corrupt VRAM doing bulk data transfers + NMI before VBlank)
  `ConfigurePPU BGAddr1|PPUInc1|NameTable20
  ; Set Background Pattern Table to 1 (Second half of CHR bank)
  ; Increment PPU I/O by 1 (Horizontal), Nametable at $2000

  ; Clear out nametables.
  JSR ClearNameTables

  ; Load the background.
  JSR RenderHonkeyKongScreen  ; Render "Honkey Kong" title card
  JSR WriteHKAttributes       ; Write Attribute Table
  JSR EnableGFX               ; Enable graphics

  ; Wait 3 seconds so everyone can see how awesome I am.
  `WaitFrames 180

  ; Set starting game state
  LDA #STATETITLE
  STA GameState

  ; Now that the game is ready, enable NMI when VBlank is on.
  ; Once the NMI triggers, it'll see that the game state is set
  ; to display the title screen, and execute that subroutine.
  `ConfigurePPU NMIonVBlank|BGAddr0|Sprite8x8|SprAddr0|PPUInc1|NameTable20
  ; Background tiles and sprites are both on Pattern Table 0

MainLoop:
  JMP MainLoop     ; Jump back, infinite loop. All game logic performed on NMI.

; Non Maskable Interrupt, run once per frame when VBlank triggers.
NMI:
  ; The VBlank period has just started, it's safe to update PPU memory.
  LDA #$00
  STA SpriteAddr  ; set the low byte (00) of the RAM address
  LDA #$02
  STA SpriteDMA   ; set the high byte (02) of the RAM address, start the transfer

  ; Check to see if either player has scored since the last frame.
  LDA ScoreP1Updated    ; Check if player 1 scored.
  CMP #$01
  BEQ +                 ; If so, jump ahead to update the point display.
  LDA ScoreP2Updated    ; If not, see if player 2 scored.
  CMP #$01
  BNE ReadPads          ; If player 2 didn't score either, branch
                        ; ahead and read the controller inputs.

* JSR DisableGFX        ; Turn off graphics and update the background.
  JSR DrawScore         ; Draw the new scores for both players.
  ; Reload the PPU configuration.
  `ConfigurePPU NMIonVBlank|BGAddr0|Sprite8x8|SprAddr0|PPUInc1|NameTable20
  JSR EnableGFX         ; Turn graphics back on.
  JSR ToggleNMI         ; Toggle the NMI off for a moment
  `waitFrames 30        ; Pause for 30 frames so the players 
                        ; can prepare for the next round.
  JSR ToggleNMI         ; Toggle NMI back on, game is playing again.

  ; PPU updates are done, run the game logic.

  ; Read the controller states.
ReadPads:
  JSR ReadController1
  JSR ReadController2

  ; Check the game state, and jump to the proper subroutine.

  LDA GameState
  CMP #STATETITLE
  BNE +
  JSR EngineTitle

* LDA GameState
  CMP #STATEPLAYING
  BNE +
  JSR EnginePlaying

* LDA GameState
  CMP #STATEGAMEOVER
  BNE +
  JSR EngineGameOver

  ; Update Sprite RAM
* JSR UpdateSprites

  RTI   ; return from interrupt

  ; Set up the 3 main vectors the NES looks for 
  ; at the end of the ROM at power-on.
  .advance $FFFA    ; First of the three vectors starts here

  .word NMI         ; Non-Maskable Interrupt, runs during VBlank, once per frame.

  .word RESET       ; This function is performed on power-on and reset.

  .word 0           ; external IRQ is not used here
